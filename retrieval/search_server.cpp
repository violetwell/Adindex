// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include <string>
#include <string.h>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <sys/time.h>
#include <pthread.h>
#include <unistd.h>

#include "thriftSearch.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>
#include <server/TThreadPoolServer.h>
#include <server/TThreadedServer.h>

#include <log4cxx/logger.h>
#include <log4cxx/logstring.h>
#include <log4cxx/propertyconfigurator.h>

#include "IndexSearch.h"

#include "Schema.h"
#include "SearchConfig.h"
#include "MinHeap.h"

#include "filter.h"
#include "handler.h"
#include "fields.h"
#include "loadconf.h"
#include "adindex.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using namespace ::log4cxx;

using boost::shared_ptr;

//using namespace  ;

//using namespace std;
LoadConf adconf;
Conf_t conf;
IndexHandler *handlers;
LoggerPtr indexLog(Logger::getLogger("adindex"));
LoggerPtr searchLog(Logger::getLogger("searchsev"));

int loadschema();
int loadindexconf();
int environment();
void *startindex(void *arg);

class thriftSearchHandler : virtual public thriftSearchIf {
 private:
  std::string s_path;
  std::string c_path;
  Schema* kschema;
  SearchConfig* search_conf;
 public:
  thriftSearchHandler() {                                 /* load schema.xml, search_conf.xml */
    char pwd[200];
	memset(pwd, 0, 200);
    if(getcwd(pwd, sizeof(pwd)-1) == NULL) {
        LOG4CXX_INFO(searchLog, "ERROR: get pwd error");
		;
    }
	std::string pwd_root = pwd;
	s_path = pwd_root + "/config/schema.xml";
    kschema = new Schema(s_path);                                                            /* load schema.xml */
	if(!kschema->init()) {
		LOG4CXX_INFO(searchLog, "ERROR: init Schema in thriftSearchHandler failed");
		exit(1);
	}
	c_path = pwd_root +  "/config/search_conf.xml";
	search_conf = new SearchConfig(c_path);                                                  /* load search_conf.xml */
	search_conf->init();

  }

  ~thriftSearchHandler() {
	  delete kschema;
	  delete search_conf;
  }
  
  void getMonitorKey(std::vector<string> &_return){
    
    if (NULL == handlers) return;
       
    IndexField *mkField = conf.schema->getField("monitorkey");
		int mkFieldLength = mkField->getLength();
    
    long            docId, docNum, length;
    bool            deleted;
    char           *mkBiref;
    Handler        *handler;
    unsigned char  *bitData;     
    
    handler = handlers->fullHandler();
    if (handler) {
        mkBiref = (char*)handler->Brifes[mkField->getNumber()];
        docNum = handler->docnum;
        bitData = handler->DelDat;
        length = handler->DelDatSize;
        if (bitData != NULL && length > 0) {
		        for (docId = 0; docId < docNum; ++docId) {
                if (docId >= 0 && (docId + 8) / 8 <= length) {
                	deleted = bitData[(docId / 8)] & ((char)1 << (7 - docId % 8));
                    if (!deleted)                                                           /* doc is not deleted */
                    	_return.push_back(std::string(mkBiref + docId * mkFieldLength, mkFieldLength));
                }
            }    
        }
    }
    
    handler = handlers->incrHandler();
    if (handler) {
        mkBiref = (char*)handler->Brifes[mkField->getNumber()];
        docNum = handler->docnum;
        bitData = handler->DelDat;
        length = handler->DelDatSize;
        if (bitData != NULL && length > 0) {
		        for (docId = 0; docId < docNum; ++docId) {
                if (docId >= 0 && (docId + 8) / 8 <= length) {
                	deleted = bitData[(docId / 8)] & ((char)1 << (7 - docId % 8));
                    if (!deleted)                                                           /* doc is not deleted */
                    	_return.push_back(std::string(mkBiref + docId * mkFieldLength, mkFieldLength));
                }
            }    
        }
    }
        
    int              ret;
    char             mkBuffer[1024];
    Realtime        *realTime;
    RAMInputStream  *mkStream = NULL;
    
    realTime = handlers->realtimeHandler();
    if (realTime) {
        docNum = realTime->getDocnum();
        mkStream = realTime->brifeSteams(mkField->getNumber());
        if (mkStream == NULL) return;
        for (docId = 0; docId < docNum; ++docId) {
            if (!realTime->isDeleted(docId)) {
                ret = mkStream->seekNow(docId * mkFieldLength);
                if (ret == 0) continue;
                ret = mkStream->readBytesNow(mkBuffer, 0, mkFieldLength); 
                if (ret < mkFieldLength) {
                    int new_len = mkFieldLength - ret;
                		long new_pos = ret;
                		if (ret < 0) continue;
                		ret = mkStream->seekNow(docId * mkFieldLength + ret);
                		if (ret == 0) continue;
                		ret = mkStream->readBytesNow(mkBuffer, new_pos , new_len);
                		if (ret < new_len) continue;
                }
                _return.push_back(std::string(mkBuffer, mkFieldLength));   
            }            
        }
        if (NULL != mkStream) free(mkStream);
    }    
  }

  void search(std::vector<QDocument> & _return, const Query& q) {
    //search start

	//get start time
	struct timeval start, end;
	gettimeofday( &start, NULL );

	//get search indexhanlder
	if (NULL == handlers) {
		return;
	}
	IndexHandler* handler = handlers;

	//init searchquery
	SearchStore* sstore = new SearchStore(handler);
	IndexSearcher* searcher = new IndexSearcher(handler);
	SearchQuery* sq = new SearchQuery(q.terms);
	if (sq->init(kschema, search_conf)) {                                            /* load query into sq */
		//LOG4CXX_INFO(searchLog, "query init ok");
		;
	} else {
		LOG4CXX_INFO(searchLog, "ERROR: query init fail");
        delete sstore;
        delete searcher;
        delete sq;
		return;
	}
	
	bool scoreRequire = false;                                                   /* true if need to return score */
	std::vector<unsigned char> retfield;                                         /* fieldId of required store-field to return, sorted */
	std::vector<unsigned char>::iterator ret_it;
    std::string id_f = "id";
    unsigned char id_field = kschema->getFid(id_f);
	int qlen = q.results.size();
	std::vector<std::string> ret_results;
	ret_results = kschema->getAllFname();
	std::vector<std::string> q_results;                                          /* fieldName of required stored field to return */
	if (qlen > 0) {
		for (int j(0); j < qlen; j++) {
			if (0 == strcmp("score", q.results[j].c_str())) {
				scoreRequire = true;
			} else {
				bool stored = kschema->getStored(q.results[j]);
				if (stored) {
					retfield.push_back(kschema->getFid(q.results[j]));
				}
			}
		}
		if (retfield.end() == find(retfield.begin(), retfield.end(), id_field)) {   /* push filedId of "id" into retfield */
			retfield.push_back(id_field);
		}
		std::sort(retfield.begin(), retfield.end());                                /* sort retfield */
	} else {
		retfield = kschema->getAllFid();                                            /* qlen = 0: return all field */
	}
	ret_it = find(retfield.begin(), retfield.end(), id_field);
	int id_index = (ret_it - retfield.begin());

	for (int j(0); j < retfield.size(); j++) {
		q_results.push_back(ret_results[int(retfield[j])]);
	}
	
	//search limit condition
	bool score2;                                                                    /* true if contains tag query */
	bool score1;                                                                    /* true if contains single or dnf query */
	int adsource = sq->getAdSource();
	int dnflen = sq->getDnfLen();
	score2 = sq->getScoreType2();
	score1 = sq->getScoreType1();
	if (q.length <= 0 || q.length > 1073741823 || q.start < 0 || q.start > 1073741822) {
		LOG4CXX_INFO(searchLog, "ERROR: Invaid query start or length");
        delete sstore;
        delete searcher;
        delete sq;
		return;
	}
	size_t ndocs = q.start + q.length;                                               /* doc count need to search */

	//search action
	std::vector<FieldDoc> rdocs;
	std::vector<FieldDoc> rdocs_1;
	rdocs_1.clear();
	std::map<int, float> fdocs;
	std::map<int, float> fdocs_1;
	fdocs_1.clear();
	if (score2) {                                                                    /* contains tag query */
		SimpleTopCollector* sitdcoll = new SimpleTopCollector(q.start, q.length, scoreRequire);
		int adpu(0);
		int adlimit(0);
		std::string sortedby("");
		SortedTopCollector* sotdcoll = NULL;
		if (2 == adsource && (dnflen > 0)) {                                         /* need both results from score1 and score2 */
			adpu = search_conf->getAdpu();
			adlimit = search_conf->getAdlimit();
			sortedby = q.sortedby;
			sotdcoll = new SortedTopCollector(q.start, q.length, scoreRequire, adpu, adlimit, sortedby, handler, kschema);
		}
		searcher->_search(sq, sitdcoll, sotdcoll);
		rdocs = sitdcoll->getResults();
		fdocs = sitdcoll->getFdocs();
		if (sotdcoll) {
			rdocs_1 = sotdcoll->getResults();
			fdocs_1 = sotdcoll->getFdocs();
		}
		delete sitdcoll;
		delete sotdcoll;

	} else if(score1) {
		if (q.sortedby.size() > 0) {
			int adpu = search_conf->getAdpu();
			int adlimit = search_conf->getAdlimit();
			std::string sortedby = q.sortedby;
			SortedTopCollector* sotdcoll = new SortedTopCollector(q.start, q.length, scoreRequire, adpu, adlimit, sortedby, handler, kschema);
			searcher->_search(sq, (Collector*)sotdcoll);
			rdocs = sotdcoll->getResults();
			fdocs = sotdcoll->getFdocs();
			delete sotdcoll;
		} else {
			NoSortedCollector* sdcoll = new NoSortedCollector(q.start, q.length, scoreRequire);
			searcher->_search(sq, (Collector*)sdcoll);
			rdocs = sdcoll->getResults();
			fdocs = sdcoll->getFdocs();
			delete sdcoll;

		}
	} else {
		LOG4CXX_INFO(searchLog, "ERROR: Invalid Query.");
        delete sstore;
	    delete searcher;
	    delete sq;
		return ;
	}


	//get search results
	QDocument retd;
	std::map<std::string, std::string> doc;
	int rdocs_size = rdocs.size();

	//uniqueid
	std::map<int, bool> uniqueids;
	std::vector<unsigned char> retid;
	std::vector<std::vector<unsigned char> > rids;                                      /* rids[i] is the store-data of Fields[i] */
	unsigned char* bufr = (unsigned char*)malloc(sizeof(unsigned char) * sizeof(int));
	memset(bufr, 0, sizeof(int));
	if (NULL == bufr) {
	    delete searcher;
	    delete sstore;
	    delete sq;
		return ;
	}
	
	std::string scorefield = "score";
	std::string scorevalue; 
	int uniqueid(0);
	for (int i(0); i < rdocs_size; i++) {
	  doc.clear();
		rids = sstore->seek(rdocs[i].doc, retfield);                                     /* search store-data of fieldId in retfield */
		if (rids.size() > 0) {
			retid = rids[id_index];                                                      /* id of doc */
    		for (int j(0); j < retid.size(); j++) {   
				bufr[j] = retid[j];
			} 
			int uniqueid = *(int*)bufr;
			if (uniqueids.end() == uniqueids.find(uniqueid)) {                           /* not adding duplicate doc with same id field */
				uniqueids.insert(std::pair<int, bool>(uniqueid, true));

				if (scoreRequire) {
					char sv[sizeof(float)];
					sprintf(sv, "%f", fdocs[rdocs[i].doc]);
					scorevalue = sv;
					doc[scorefield] = scorevalue;                                        /* score field */
				} 
				for (int m(0); m < rids.size(); m++) {                                   /* store other fields into doc */
					std::string rstr;
					rstr = kschema->Tostr(q_results[m], rids[m]);
					doc[q_results[m]] = rstr;
					retd.__set_fields(doc);
				}
					
				_return.push_back(retd);                                                 /* push doc to _return */
			}
		}
	}

	uniqueids.clear();
	memset(bufr, 0, sizeof(int));
	for (int i(0); i < rdocs_1.size(); i++) {
		rids = sstore->seek(rdocs_1[i].doc, retfield);
		if (rids.size() > 0) {
			retid = rids[id_index];
			for (int j(0); j < retid.size(); j++) {
				bufr[j] = retid[j];
			}
			int uniqueid = *(int*)bufr;
			if (uniqueids.end() == uniqueids.find(uniqueid)) {
				uniqueids.insert(std::pair<int, bool>(uniqueid, true));

				if (scoreRequire) {
					char sv[sizeof(float)];
					sprintf(sv, "%f", fdocs_1[rdocs_1[i].doc]);
					scorevalue = sv;
					doc[scorefield] = scorevalue;
				}

				for (int m(0); m < rids.size(); m++) {
					std::string rstr;
					rstr = kschema->Tostr(q_results[m], rids[m]);
					doc[q_results[m]] = rstr;
					retd.__set_fields(doc);
				}

				_return.push_back(retd);
			}
		}
	}
	
    if (bufr != NULL) {
        free(bufr);
    }
	delete searcher;
	delete sstore;
	delete sq;

	gettimeofday( &end, NULL );
	long total_time = (end.tv_sec * 1000 + end.tv_usec / 1000) - (start.tv_sec * 1000 + start.tv_usec / 1000);
  /*
	//search log
	std::string log = "";
	for (int i(0); i < q.terms.single_query.size(); i++) {
		log += q.terms.single_query[i].qkey;
		log += ":";
		log += q.terms.single_query[i].qval;
		log += ",";
	}
	log += " ";
	for (int i(0); i < q.terms.filter.size(); i++) {
                log += q.terms.filter[i].qkey;
                log += ":";
                log += q.terms.filter[i].qval;
                log += ",";
	}
	if (q.terms.dnf.size() > 0) {
		log += " dnf:";
	}
	for (int i(0); i < q.terms.dnf.size(); i++) {
		char dnf[20];
		sprintf(dnf, "%lld", q.terms.dnf[i]);
		log += dnf;
		log += ",";
	}
	if (q.terms.tags.size() > 0) {
		log += " tags:";
	}
    for (int i(0); i < q.terms.tags.size(); i++) {
		char dnf[20];
        sprintf(dnf, "%lld", q.terms.tags[i]);
        log += dnf;
		log += ",";
    }
	LOG4CXX_INFO(searchLog, "search " << log << " " << q.start << " to " << q.length << " sortedby " << q.sortedby <<" get " << rdocs_size << " in " << total_time << " ms");
	*/
  }

};

int main(int argc, char **argv) {
  //start adindex handler
  pthread_t tid;
  pthread_create(&tid, NULL, startindex, NULL);


  //init thrift server
  char pwd[200];
  memset(pwd, 0, 200);
  if (getcwd(pwd, sizeof(pwd)-1) == NULL) {
      LOG4CXX_INFO(searchLog,"get pwd error");
	  exit(1);
  }
  strcat(pwd, "/config/conf.txt");

  //FILE* filefp  = fopen(pwd, "r");
  std::ifstream file;
  file.open(pwd);
  if (!file.is_open()) {
      LOG4CXX_INFO(searchLog,"error can't open conf.txt");
      exit(1);
  }

  sleep(5);

  int port;
  file >> port;
  file.close();
  
  shared_ptr<thriftSearchHandler> handler(new thriftSearchHandler());
  shared_ptr<TProcessor> processor(new thriftSearchProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  int multinum = 6144;
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(multinum);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  printf("start redis server...%d thread\n", multinum);

  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
  //TThreadedServer server(processor,serverTransport,transportFactory,protocolFactory);
  server.serve();
  return 0;
}


void *startindex(void *arg) {
	if (loadindexconf() <= 0) {
		LOG4CXX_INFO(indexLog, "load index config file error, adindex exit");
		exit(-1);
	}
    IndexSchema *schema = new IndexSchema();
	conf.schema = schema;
	int res = 0;
	if (loadschema() <= 0) {
		LOG4CXX_INFO(indexLog, "load index schema file error, adindex exit");
		exit(-1);
	}
	if (environment() <= 0) {
		LOG4CXX_INFO(indexLog, "init environment error, adindex exit");
		exit(-1);
	}
	if (strcmp(conf.mode, REALTIME_MODE) == 0) {
		LOG4CXX_INFO(indexLog, "start adindex with realtime model");
		char tpfile[MAX_DIR_LEN];
		int i = 0;
		conf.fullDelRef = NULL;
		conf.incrDelRef = NULL;
		conf.addupdateCounter = 0;
		string topicstr(conf.topic);
		std::vector<InnerDocument> docs;
		IndexField *keyField = schema->getPrimary();
		boost::shared_ptr<TTransport> transport;
		InnerIndexClient *client = NULL;
		bool nodata = false;
		int cusumedDoc = 0;
		int res = 0;
		handlers = new IndexHandler(NULL, NULL, NULL);
		Handler *fullHandler = new Handler(conf.fullindex, schema);                       /* fullHandler */
		if (fullHandler->init() <= 0) {                                                   /* load files */
			LOG4CXX_INFO(indexLog, "full index handler init fail");
			delete fullHandler;
			fullHandler = NULL;
		} else {
			char *idbrife = (char*)fullHandler->Brifes[keyField->getNumber()];
			int num = fullHandler->docnum;
			long *ids = (long*)malloc(sizeof(long) * num);
			for (i = 0; i < num; i++) {
				int ch1 = (int)(idbrife[i * 4] & 0xff);
				int ch2 = (int)(idbrife[i * 4 + 1] & 0xff);
				int ch3 = (int)(idbrife[i * 4 + 2] & 0xff);
				int ch4 = (int)(idbrife[i * 4 + 3] & 0xff);
				ids[i] = (long)(ch1 + (ch2 << 8) + (ch3 << 16) + (ch4 << 24));
			}
			DocIDMapper *mapper = new DocIDMapper(ids, num);                               /* quick search docId of ids */
			DelRef *ref = (DelRef*)malloc(sizeof(DelRef));                                 /* construct fullDelRef */
			ref->mapper = mapper;
			ref->bitdata = (char*)fullHandler->DelDat;
			ref->length = fullHandler->DelDatSize;
			char *delFile = (char*)malloc(sizeof(char) * 1024);
			snprintf(delFile, 1024, "%s%s", conf.fullindex, INDEX_DEL);
			ref->filePath = delFile;
			conf.fullDelRef = ref;
			LOG4CXX_INFO(indexLog, "full index/mapper load success");
		}
	    handlers->setFullHandler(fullHandler);                                              /* set fullHandler, init fullReader */
		Handler *incrHandler = new Handler(conf.incrindex, schema);                         /* incrHandler, same as fullHandler */
		if (incrHandler->init() <= 0) {
			LOG4CXX_INFO(indexLog, "incr index handler init fail");
			delete incrHandler;
			incrHandler = NULL;
		} else {
			char *idbrife = (char*)incrHandler->Brifes[keyField->getNumber()];
			int num = incrHandler->docnum;
			long *ids = (long*)malloc(sizeof(long) * num);
			for (i = 0; i < num; i++) {
				int ch1 = (int)(idbrife[i * 4] & 0xff);
				int ch2 = (int)(idbrife[i * 4 + 1] & 0xff);
				int ch3 = (int)(idbrife[i * 4 + 2] & 0xff);
				int ch4 = (int)(idbrife[i * 4 + 3] & 0xff);
				ids[i] = (long)(ch1 + (ch2 << 8) + (ch3 << 16) + (ch4 << 24));
			}
			DocIDMapper *mapper = new DocIDMapper(ids, num);
			DelRef *ref = (DelRef*)malloc(sizeof(DelRef));
			ref->mapper = mapper;
			ref->bitdata = (char*)incrHandler->DelDat;
			ref->length = incrHandler->DelDatSize;
			char *delFile = (char*)malloc(sizeof(char) * 1024);
			snprintf(delFile, 1024, "%s%s", conf.incrindex, INDEX_DEL);
			ref->filePath = delFile;
			conf.incrDelRef = ref;
			LOG4CXX_INFO(indexLog, "incr index/mapper load success");
		}
	    handlers->setIncrHandler(incrHandler);
		Realtime *realtime = new Realtime(&conf);                                           /* realtime Handler */
		if (!realtime->ready()) {
			LOG4CXX_FATAL(indexLog, "init first realtime fail for leveldb dict");
			realtime->close();
			delete realtime;
			realtime = NULL;
		}
		handlers->setRealtimeHandler(realtime);
		while (1) {                                                                                                  /* consume docs in commitlog */
			if (nodata) sleep(1);
			if (realtime == NULL) {
				sleep(10);
				continue;
			}
			docs.clear();
			try {
				if (client == NULL) {                                                                                /* connect to commitlog */
				    boost::shared_ptr<TSocket> socket(new TSocket(conf.innerindexip, conf.innerindexport));
				    boost::shared_ptr<TTransport> newtransport(new TBufferedTransport(socket));
				    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(newtransport));
				    socket->setRecvTimeout(6000);
				    socket->setConnTimeout(6000);
					transport = newtransport;
				    transport->open();
					LOG4CXX_INFO(indexLog, "commitlog service open success");
					client = new InnerIndexClient(protocol);
				}
				client->loadData(docs, topicstr, conf.messageId, 10);                                                 /* load 10 docs, start from messageId */
				if (docs.size() > 0) {
					LOG4CXX_INFO(indexLog, "load doc from commitlog num: " << docs.size());
				}
				if (docs.size() > 0) {
					nodata = false;
					int i = 0;
					for (i = 0; i < (int)docs.size(); i++) {                                                                        /* handle docs[i] */
						InnerDocument document = docs[i];
						long id = document.id;
						//conf.messageId = id + 1;
						string data = document.data;
						int dataLen =  document.dataLen;
						if (dataLen < 7) {
							LOG4CXX_WARN(indexLog, "doc data length less then 7, abandon this message, id:"<<id);
							continue;
						}
						char *dataptr = (char*)data.c_str();
						if (dataptr[0] == 0) {                                                                                       /* message for delete, data(7bytes): 0 126 docId(4byte) 127 */
							if (dataLen != 7) {
								LOG4CXX_WARN(indexLog, "doc data length not 7 for delete, abandon this message, id:"<<id);
								continue;
							}
							if (dataptr[1] != 126 || dataptr[6] != 127) {
								LOG4CXX_WARN(indexLog, "doc data not standard format for delete, abandon this message, id:"<<id);
								continue;
							}
							int ch1 = (int)(dataptr[2] & 0xff);
							int ch2 = (int)(dataptr[3] & 0xff);
							int ch3 = (int)(dataptr[4] & 0xff);
							int ch4 = (int)(dataptr[5] & 0xff);
							if ((ch1 | ch2 | ch3 | ch4) < 0) {
								LOG4CXX_WARN(indexLog, "doc data not standard format for delete, abandon this message, id:"<<id);
								continue;
							}
							int uid = (ch1 + (ch2 << 8) + (ch3 << 16) + (ch4 << 24));                                                 /* uid to delete */
							res = realtime->deleteDoc(uid);                                                                           /* delete doc */
							if (res <= 0) {
								LOG4CXX_WARN(indexLog, "delete doc fail: "<<uid);
							} else {
								LOG4CXX_INFO(indexLog, "delete doc success: "<<uid);
							}
						} else if (dataptr[0] == 1) {                                                                                 /* message for update, data: 1 126 docData 127 */
							if (dataptr[1] != 126 || dataptr[dataLen - 1] != 127) {
								LOG4CXX_WARN(indexLog, "doc data not standard format for delete, abandon this message, id:"<<id);
								continue;
							}
							res = realtime->addDoc(dataptr + 1, dataLen - 1);
							if (res <= 0) {
								LOG4CXX_WARN(indexLog, "add/update doc fail, id:"<<id);
								continue;
							}
							LOG4CXX_INFO(indexLog, "add/update doc success, id:"<<id);
							cusumedDoc++;
							conf.addupdateCounter++;
						} else {
							LOG4CXX_WARN(indexLog, "doc data not standard format for delete/update, abandon this message, id:"<<id);
							continue;
						}
					}
					conf.messageId += docs.size();                                                                                     /* increase messageId */
				} else {
					nodata = true;
					continue;
				}
				LOG4CXX_INFO(indexLog, "message id consumed: "<<(conf.messageId - 1));
				if (cusumedDoc >= 10000) {                                                                                             /* merge realtime with incr */
					cusumedDoc = 0;
					Handler *newincrHandler = NULL;
					bool flag = true;
					snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.realtimeindex, "*");
					Utils::rmdirectory(tpfile);
					int res = realtime->close();                                                                /* write realtime to disk */
					if (res <= 0) {
						flag = false;
						LOG4CXX_FATAL(indexLog, "realtime index store fail");
					} else {
						if (handlers->incrHandler() == NULL) {                                                  /* if incr is empty, copy realtime to incr to merge */
							snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.incrindex, "*");
							Utils::rmdirectory(tpfile);
							snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.incrdict, "*");
							Utils::rmdirectory(tpfile);
							Utils::copydirectory(conf.realtimeindex, conf.incrindex);
							Utils::copydirectory(conf.realtimedict, conf.incrdict);
							newincrHandler = new Handler(conf.incrindex, schema);
							if (newincrHandler->init() <= 0) {
								LOG4CXX_FATAL(indexLog, "realtime flush to disk reload fail");
								delete newincrHandler;
								newincrHandler = NULL;
								flag = false;
							}
						} else {                                                                                /* merge realtime with incr */
							snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.merger, "*");
							Utils::rmdirectory(tpfile);
							IncrMerger *merger = new IncrMerger(&conf, conf.merger, true, 
							conf.incrindex, conf.realtimeindex, conf.incrdict, conf.realtimedict);
							if (merger->merge() > 0) {                                                          /* merge into merger, delete deleted docs */
								//bak
								snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.tempindex, "*");
								Utils::rmdirectory(tpfile);
								snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.tempdict, "*");
								Utils::rmdirectory(tpfile);
								Utils::copydirectory(conf.incrindex, conf.tempindex);                           /* copy incr to temp */
								Utils::copydirectory(conf.incrdict, conf.tempdict);
								
								LOG4CXX_INFO(indexLog, "incr merge success");
								snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.incrindex, "*");
								Utils::rmdirectory(tpfile);                                                     /* clear incr */
								Utils::copydirectory(conf.merger, conf.incrindex);                              /* copy merger into incr */
								newincrHandler = new Handler(conf.incrindex, schema);                           /* restart incrHanlder */
								if (newincrHandler->init() <= 0) {
									LOG4CXX_FATAL(indexLog, "incr merge flush to disk reload fail");
									delete newincrHandler;
									newincrHandler = NULL;
									flag = false;
								}
							} else {
								LOG4CXX_FATAL(indexLog, "incr merge fail");
								flag = false;
							}
							delete merger;
						}
					}
					if (flag) {                                                                  /* merge success, restart handlers */
						Handler *oldIncr = handlers->incrHandler();
						Realtime *oldRealtime = handlers->realtimeHandler();
						DelRef *oldIncrRef = conf.incrDelRef;
						IndexHandler *oldHandlers = handlers;
						IndexHandler *temphandlers = new IndexHandler(handlers->fullHandler(), newincrHandler, NULL);
						handlers = temphandlers;
						LOG4CXX_INFO(indexLog, "index view changed without realtime");
						sleep(60);
						if (oldIncrRef != NULL) {
							char *filePath = oldIncrRef->filePath;
							DocIDMapper *mapper = oldIncrRef->mapper;
							if (filePath != NULL) free(filePath);
							if (mapper != NULL) delete mapper;
							free(oldIncrRef);
						}
						if (oldRealtime != NULL) delete oldRealtime;
						if (oldIncr != NULL) delete oldIncr;
						delete oldHandlers;
						char *idbrife = (char*)newincrHandler->Brifes[keyField->getNumber()];
						int num = newincrHandler->docnum;
						long *ids = (long*)malloc(sizeof(long) * num);
						for (i = 0; i < num; i++) {
							int ch1 = (int)(idbrife[i * 4] & 0xff);
							int ch2 = (int)(idbrife[i * 4 + 1] & 0xff);
							int ch3 = (int)(idbrife[i * 4 + 2] & 0xff);
							int ch4 = (int)(idbrife[i * 4 + 3] & 0xff);
							ids[i] = (long)(ch1 + (ch2 << 8) + (ch3 << 16) + (ch4 << 24));
						}
						DocIDMapper *mapper = new DocIDMapper(ids, num);
						DelRef *ref = (DelRef*)malloc(sizeof(DelRef));
						ref->mapper = mapper;
						ref->bitdata = (char*)newincrHandler->DelDat;
						ref->length = newincrHandler->DelDatSize;
						char *delFile = (char*)malloc(sizeof(char) * 1024);
						snprintf(delFile, 1024, "%s%s", conf.incrindex, INDEX_DEL);
						ref->filePath = delFile;
						conf.incrDelRef = ref;
						realtime = new Realtime(&conf);
						if (!realtime->ready()) {
							LOG4CXX_FATAL(indexLog, "init realtime fail for leveldb dict");
							realtime->close();
							delete realtime;
							realtime = NULL;
						}
						handlers->setRealtimeHandler(realtime);
						LOG4CXX_INFO(indexLog, "index view changed with new realtime @messageid: "<<conf.messageId);
						FILE *idFp = fopen(conf.incridfile, "w");
						snprintf(tpfile, MAX_DIR_LEN, "%ld\n", conf.messageId);
						fwrite(tpfile, sizeof(char), strlen(tpfile), idFp);                               /* update messageId in disk */
						fclose(idFp);
					} else {
						if (newincrHandler != NULL) {
							delete newincrHandler;
						}
						realtime = NULL;
						LOG4CXX_FATAL(indexLog, "realtime exchange fail");
					}
				}
			} catch (TException &tx) {
				nodata = true;
				if (transport != NULL) {
					try {
					    transport->close();
					} catch (TException &ctx) {
					}
				}
				if (client != NULL) {
					delete client;
					client = NULL;
				}
				LOG4CXX_WARN(indexLog, "commitlog thrift service exception: " + string(tx.what()));
			}
		}
	} else {
		IndexField *keyField = schema->getPrimary();
		DocParser *parser = new DocParser(0, conf.fullsource, schema);
		conf.parser = parser;
		Brife *brife = new Brife(&conf);
		Store *store = new Store(&conf);
		Inverted *inverted = new Inverted(&conf);
		int docid = 0;
		while (parser->hasNext()) {                                                            /* parse raw doc files */
			char *key = parser->data(keyField->getNumber());
			if (key == NULL) continue;
			int res = inverted->index(parser);
			if (res <= 0) continue;
			res = brife->saveDoc(parser);
			res = store->saveDoc(parser);
			LOG4CXX_INFO(indexLog, "index doc: "<<docid++);
		}
		brife->close();
		store->close();
		inverted->close();
		delete brife;
		delete store;
		delete inverted;
		delete parser;
		int groupnum = (docid + conf.indexmaxdoc - 1) / conf.indexmaxdoc;
		int *ids = (int*)malloc(sizeof(int) * groupnum);
		int i = 0;
		for (i = 0; i < groupnum; i++) ids[i] = i;
		FullMerger *merger = new FullMerger(&conf, conf.fullindex, true, conf.index, conf.index, ids, groupnum, -1);
		if (merger->merge() <= 0) {
			res = 0;
		} else {
			res = 1;
		}
		free(ids);
		delete merger;
	}
	delete schema;
    return ((void *)0);
}

int loadindexconf() {
	char pwd[200];
	memset(pwd, 0, 200);
    if(getcwd(pwd, sizeof(pwd)-1) == NULL)
    {
        //printf("get pwd error \n");
		;
    }
	strcat(pwd, "/config/adindexconf.txt");
	if (adconf.load_conf(pwd) <= 0) {
		LOG4CXX_INFO(indexLog, "can't load config file");
		return -1;
	}
	int indexmaxdoc = adconf.get_int("indexmaxdoc");
	if (indexmaxdoc < 10) return -1;
	LOG4CXX_INFO(indexLog, "full index max doc: "<<indexmaxdoc);
	conf.indexmaxdoc = indexmaxdoc;
	int storemaxdoc = adconf.get_int("storemaxdoc");
	if (storemaxdoc < 1000000) return -1;
	LOG4CXX_INFO(indexLog, "index max store doc: "<<storemaxdoc);
	conf.storemaxdoc = storemaxdoc;
	char *schemafile = adconf.get_str("schemafile");
	if (schemafile == NULL) return -1;
	LOG4CXX_INFO(indexLog, "schema file path: "<<schemafile);
	conf.schemafile = schemafile;
	char *fullsource = adconf.get_str("fullsource");
	if (fullsource == NULL) return -1;
	LOG4CXX_INFO(indexLog, "full index source path: "<<fullsource);
	conf.fullsource = fullsource;
	char *index = adconf.get_str("index");
	if (index == NULL) return -1;
	LOG4CXX_INFO(indexLog, "index file path: "<<index);
	conf.index = index;
	char *merge = adconf.get_str("merge");
	if (merge == NULL) return -1;
	LOG4CXX_INFO(indexLog, "merge file path: "<<merge);
	conf.merger = merge;
	char *fullindex = adconf.get_str("fullindex");
	if (fullindex == NULL) return -1;
	LOG4CXX_INFO(indexLog, "full index file path: "<<fullindex);
	conf.fullindex = fullindex;
	char *incrindex = adconf.get_str("incrindex");
	if (incrindex == NULL) return -1;
	LOG4CXX_INFO(indexLog, "incr index file path: "<<incrindex);
	conf.incrindex = incrindex;
	char *realtimeindex = adconf.get_str("realtimeindex");
	if (realtimeindex == NULL) return -1;
	LOG4CXX_INFO(indexLog, "realtime index file path: "<<realtimeindex);
	conf.realtimeindex = realtimeindex;
	char *tempindex = adconf.get_str("tempindex");
	if (tempindex == NULL) return -1;
	LOG4CXX_INFO(indexLog, "temp index file path: "<<tempindex);
	conf.tempindex = tempindex;
	char *fulldict = adconf.get_str("fulldict");
	if (fulldict == NULL) return -1;
	LOG4CXX_INFO(indexLog, "full dict path: "<<fulldict);
	conf.fulldict = fulldict;
	char *incrdict = adconf.get_str("incrdict");
	if (incrdict == NULL) return -1;
	LOG4CXX_INFO(indexLog, "incr dict path: "<<incrdict);
	conf.incrdict = incrdict;
	char *realtimedict = adconf.get_str("realtimedict");
	if (realtimedict == NULL) return -1;
	LOG4CXX_INFO(indexLog, "realtime dict path: "<<realtimedict);
	conf.realtimedict = realtimedict;
	char *tempdict = adconf.get_str("tempdict");
	if (tempdict == NULL) return -1;
	LOG4CXX_INFO(indexLog, "temp dict path: "<<tempdict);
	conf.tempdict = tempdict;
	char *innerindexip = adconf.get_str("innerindexip");
	if (innerindexip == NULL) return -1;
	LOG4CXX_INFO(indexLog, "inner index service ip: "<<innerindexip);
	conf.innerindexip = innerindexip;
	int innerindexport = adconf.get_int("innerindexport");
	if (innerindexport <= 1024) return -1;
	LOG4CXX_INFO(indexLog, "inner index service port: "<<innerindexport);
	conf.innerindexport = innerindexport;
	char *mode = adconf.get_str("mode");
	if (mode == NULL) return -1;
	LOG4CXX_INFO(indexLog, "adindex start mode: "<<mode);
	conf.mode = mode;
	char *incridfile = adconf.get_str("incridfile");
	if (incridfile == NULL) return -1;
	LOG4CXX_INFO(indexLog, "incr message id path: "<<incridfile);
	conf.incridfile = incridfile;
	char *topic = adconf.get_str("topic");
	if (topic == NULL) return -1;
	LOG4CXX_INFO(indexLog, "adindex start topic: "<<topic);
	conf.topic = topic;
	return 1;
}

int loadschema() {
	IndexSchema *schema = conf.schema;
	TiXmlDocument *doc = new TiXmlDocument(conf.schemafile);
    bool loadOkay = doc->LoadFile();
    if (!loadOkay) {
		LOG4CXX_INFO(indexLog, "can't load schema file");
		return 0;
    }
	TiXmlElement *root = doc->RootElement();
    TiXmlElement *fields = root->FirstChildElement();
    TiXmlElement *field = NULL;
    int count = 0, num = 0;
	char *tmp = (char*)malloc(1024);
    for (field = fields->FirstChildElement(); field; field = field->NextSiblingElement()) {
		num = 0;
		int length = -1;
		char *name, *type;
		bool indexed = false, stored = false, filter = false;
		const char *value = field->Attribute(INDEX_SCHEMA_NAME);
		if (value == NULL || strlen(value) == 0) return 0;
		strcpy(tmp + num, value);
		name = tmp + num;
		num += strlen(value);
		tmp[num++] = 0;
		value = field->Attribute(INDEX_SCHEMA_TYPE);
		if (value == NULL || strlen(value) == 0) return 0;
		strcpy(tmp + num, value);
		type = tmp + num;
		num += strlen(value);
		tmp[num++] = 0;
		value = field->Attribute(INDEX_SCHEMA_LENGTH);
		if (value != NULL || strlen(value) > 0) {
			length = atoi(value);
		}
		value = field->Attribute(INDEX_SCHEMA_INDEXED);
		if (value != NULL || strlen(value) > 0) {
			if (strcmp(value, "true") == 0) indexed = true;
		}
		value = field->Attribute(INDEX_SCHEMA_STORED);
		if (value != NULL || strlen(value) > 0) {
			if (strcmp(value, "true") == 0) stored = true;
		}
		value = field->Attribute(INDEX_SCHEMA_FILTER);
		if (value != NULL || strlen(value) > 0) {
			if (strcmp(value, "true") == 0) filter = true;
		}
		IndexField *field = new IndexField(name, count, type, length, indexed, stored, filter);
		schema->addField(*(new string(name)), field);
		count++;
    }
    TiXmlElement *id = fields->NextSiblingElement();
	if (NULL == id) return 0;
	else {
		const char *value = id->Attribute(INDEX_SCHEMA_KEY);
		if (value == NULL || strlen(value) == 0) return 0;
		else {
			string s(value);
			IndexField *get = schema->getField(s);
			if (get == NULL) return 0;
			else {
				schema->setPrimary(get);
			}
		}
	}
	free(tmp);
	return 1;
}

int environment() {
	char tpfile[MAX_DIR_LEN];
	if (strcmp(conf.mode, REALTIME_MODE) == 0) {
		conf.messageId = 0;
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.realtimeindex, "*");
		Utils::rmdirectory(tpfile);                                                                 /* remove realtime index */
		LOG4CXX_INFO(indexLog, "realtime index path has been cleared");
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.realtimedict, "*");
		Utils::rmdirectory(tpfile);                                                                 /* remove realtime dic */
		LOG4CXX_INFO(indexLog, "realtime index leveldb data path has been cleared");
		if (Utils::existFile(conf.incridfile)) {                                                    /* init message id */
			FILE *idFp = fopen(conf.incridfile, "r");
			if (fgets(tpfile, MAX_DIR_LEN, idFp) == NULL) {
				fclose(idFp);
				LOG4CXX_INFO(indexLog, "incrid conf file can't be opened");
				return -1;
			} else {
				fclose(idFp);
				conf.messageId = std::atol(tpfile);
				if (conf.messageId < 0) {
					LOG4CXX_INFO(indexLog, "incrid less then zero");
					return -1;
				}
			}
		} else {
			FILE *idFp = fopen(conf.incridfile, "w");
			if (idFp == NULL) {
				LOG4CXX_INFO(indexLog, "incrid conf file can't be opened");
				return -1;
			}
			snprintf(tpfile, MAX_DIR_LEN, "%ld\n", 0l);                                             /* if message id not found, init to 0 */
			int res = fwrite(tpfile, sizeof(char), strlen(tpfile), idFp);
			if (res != (int)strlen(tpfile)) {
				LOG4CXX_INFO(indexLog, "incrid conf file can't be writted");
				return -1;
			}
			fclose(idFp);
		}
		boost::shared_ptr<TSocket> socket(new TSocket(conf.innerindexip, conf.innerindexport));      /* test connection to commitlog service */
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		socket->setRecvTimeout(6000);
		socket->setConnTimeout(6000);
		try {
			transport->open();
			LOG4CXX_INFO(indexLog, "commitlog service for test open ok");
			transport->close();
			LOG4CXX_INFO(indexLog, "commitlog service for test closed");
		} catch (TException &tx) {
			LOG4CXX_INFO(indexLog, "commitlog service for test open fail, start adindex fail");
			return -1;
		}
		return 1;
	} else if (strcmp(conf.mode, FULL_MODE) == 0) {
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.index, "*");
		Utils::rmdirectory(tpfile);
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.merger, "*");
		Utils::rmdirectory(tpfile);
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.fullindex, "*");
		Utils::rmdirectory(tpfile);
		LOG4CXX_INFO(indexLog, "full index path(temp, merge, index) has been cleared");
		snprintf(tpfile, MAX_DIR_LEN, "%s%s", conf.fulldict, "*");
		Utils::rmdirectory(tpfile);
		LOG4CXX_INFO(indexLog, "full index leveldb data path has been cleared");
		return 1;
	} else {
	    LOG4CXX_INFO(indexLog, "unavailable start mode(full/realtime)");
	    return -1;
	}
}



